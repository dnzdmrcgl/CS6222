{
    "collab_server" : "",
    "contents" : "library(GenomicFeatures)\nlibrary(GenomicAlignments)\nlibrary(Rsamtools)\nlibrary(VariantAnnotation)\nlibrary(ggplot2)\n\nreadBedFile <- function(bedFilePath) {\n    df <- read.table(bedFilePath, header=F, stringsAsFactors=F)\n    names(df) <- c('chr','start','end')\n    gr <- with(df, GRanges(chr, IRanges(start, end)))\n    return(gr)\n}\n\nloadTrainingData <- function(parentDirectory = '../data/training/', directory = 'syn1') {\n  dataDirectory <- paste0(parentDirectory, directory, '/')\n  tumorBam <- NULL\n  normalBam <- NULL\n  \n  freebayesFilePath <- paste0(dataDirectory, directory, '_', 'freebayes.vcf')\n  mutectFilePath <- paste0(dataDirectory, directory, '_', 'mutect.vcf')\n  vardictFilePath <- paste0(dataDirectory, directory, '_', 'vardict.vcf')\n  varscanFilePath <- paste0(dataDirectory, directory, '_', 'varscan.vcf')\n  truthFilePath <- paste0(dataDirectory, directory, '_', 'truth.bed')\n  \n  freebayesVCF <- rowRanges(readVcf(freebayesFilePath, 'hg19'))\n  mutectVCF <- rowRanges(readVcf(mutectFilePath, 'hg19'))\n  vardictVCF <- rowRanges(readVcf(vardictFilePath, 'hg19'))\n  varscanVCF <- rowRanges(readVcf(varscanFilePath, 'hg19'))\n  \n  truthSet <- readBedFile(truthFilePath)\n  \n  if ( substr(directory, 1, 3) == 'syn' ) {\n    normalBamFilePath <- paste0(dataDirectory, directory, '_', 'normal.bam')\n    tumorBamFilePath <- paste0(dataDirectory, directory, '_', 'tumor.bam')\n    normalBam <- readGAlignments(BamFile(normalBamFilePath))\n    tumorBam <- readGAlignments(BamFile(tumorBamFilePath))\n  }\n  \n  return(list(freebayesVCF = freebayesVCF, mutectVCF = mutectVCF, vardictVCF = vardictVCF, \n              varscanVCF = varscanVCF, truthSet = truthSet, normalBam = normalBam, tumorBam = tumorBam))\n}\n\ngetAllPredictions <- function(sampleData) {\n  allPredictions <- unique(c(sampleData$freebayesVCF, sampleData$mutectVCF, sampleData$vardictVCF, sampleData$varscanVCF))\n  \n  allPredictions$freebayesSNP <- overlapsAny(allPredictions, sampleData$freebayesVCF, type = 'equal')\n  allPredictions$mutectSNP <- overlapsAny(allPredictions, sampleData$mutectVCF, type = 'equal')\n  allPredictions$vardictSNP <- overlapsAny(allPredictions, sampleData$vardictVCF, type = 'equal')\n  allPredictions$varscanSNP <- overlapsAny(allPredictions, sampleData$varscanVCF, type = 'equal')\n  \n  allPredictions$truthTable <- overlapsAny(allPredictions, sampleData$truthSet, type = 'equal')\n  \n  return(allPredictions)\n}\n\ngetRandomSample <- function(syn1.predictions, percentage) {\n  index1 <- sample(1:length(syn1.predictions), as.integer(length(syn1.predictions) * percentage), replace = TRUE)\n  index2 <- sample(1:length(syn1.predictions), as.integer(length(syn1.predictions) * percentage), replace = TRUE)\n  index3 <- sample(1:length(syn1.predictions), as.integer(length(syn1.predictions) * percentage), replace = TRUE)\n  index4 <- sample(1:length(syn1.predictions), as.integer(length(syn1.predictions) * percentage), replace = TRUE)\n  \n  return(list(index1 = index1, index2 = index2, index3 = index3, index4 = index4))\n}\n\nmajorityVoting <- function(n, trueCounts, falseCounts, truthValues) {\n  if(trueCounts[n] > falseCounts[n]) {\n    return(1)\n  } else if (trueCounts[n] == falseCounts[n]) {\n    return(as.numeric(sample(truthValues[n,], 1)))\n  } else {\n    return (0)\n  }\n}\n\ngetPrediction <- function(query, sample.predictions, indexList) {\n  overlapTable <- findOverlaps(query, sample.predictions, type = 'equal') \n  if (length(overlapTable) == 0) {\n    return (0)\n  }\n  \n  queryIndex <- subjectHits(overlapTable)\n  \n  table.index1 <- table(indexList$index1)\n  table.index2 <- table(indexList$index2)\n  table.index3 <- table(indexList$index3)\n  table.index4 <- table(indexList$index4)\n  \n  times1 <- table.index1[match(queryIndex, names(table.index1))]\n  times2 <- table.index2[match(queryIndex, names(table.index2))]\n  times3 <- table.index3[match(queryIndex, names(table.index3))]\n  times4 <- table.index4[match(queryIndex, names(table.index4))]\n  \n  times1[is.na(times1)] <- 0\n  times2[is.na(times2)] <- 0\n  times3[is.na(times3)] <- 0\n  times4[is.na(times4)] <- 0\n  \n  times <- matrix(c(times1, times2, times3, times4), nrow = length(times1))\n  truthValues <- as.matrix(mcols(sample.predictions[queryIndex])[,c('freebayesSNP', 'mutectSNP', 'vardictSNP', 'varscanSNP')])\n  \n  result <- times * truthValues\n  trueCounts <- rowSums(result)\n  falseCounts <- rowSums(times) - trueCounts\n  \n  pred <- sapply(1:length(trueCounts), majorityVoting, trueCounts, falseCounts, truthValues)\n  return(pred)\n}\n\ngetGroundTruth <- function(query, sample.predictions) {\n  overlapTable <- findOverlaps(query, sample.predictions, type = 'equal')\n  return(as.numeric(sample.predictions[subjectHits(overlapTable)]$truthTable))\n}\n\nevaluatePerformance <- function(predictions, labels) {\n  true.positive <- sum((predictions + labels) == 2)\n  test.outcome.positive <- sum(predictions)\n  condition.positive <- sum(labels)\n  \n  precision <- true.positive / test.outcome.positive\n  recall <- true.positive / condition.positive\n  f1.score <- (2 * precision * recall) / (precision + recall)\n  return(c(f1.score = f1.score, precision = precision, recall = recall))\n}\n\nmultipleSamplingRun <- function(query, sample.predictions, numberOfSampling, samplingPercentage) {\n  predictions <- rep(0, length(query))\n  truePredictions <- getGroundTruth(query, sample.predictions)\n  majorityVote <- as.integer(numberOfSampling / 2)\n  for(i in 1:numberOfSampling) {\n    sample.indexList <- getRandomSample(sample.predictions, samplingPercentage)\n    predictions <- predictions + getPrediction(query, sample.predictions, sample.indexList)\n  }\n  predictions <- as.numeric(predictions > majorityVote)\n  performance <- evaluatePerformance(predictions, truePredictions)\n  return(performance)\n}\n\ngetPerformance <- function(sample, sampleName, samplingRates, samplingNumber) {\n  numberOfSampling <- samplingNumber[[1]]\n  sampling.1 <- sapply(samplingRates, function(p) {multipleSamplingRun(sample, sample, numberOfSampling, samplingPercentage = p)})\n  \n  numberOfSampling <- samplingNumber[[2]]\n  sampling.2 <- sapply(samplingRates, function(p) {multipleSamplingRun(sample, sample, numberOfSampling, samplingPercentage = p)})\n  \n  numberOfSampling <- samplingNumber[[3]]\n  sampling.3 <- sapply(samplingRates, function(p) {multipleSamplingRun(sample, sample, numberOfSampling, samplingPercentage = p)})\n  \n  numberOfSampling <- samplingNumber[[4]]\n  sampling.4 <- sapply(samplingRates, function(p) {multipleSamplingRun(sample, sample, numberOfSampling, samplingPercentage = p)})\n  \n  numberOfSampling <- samplingNumber[[5]]\n  sampling.5 <- sapply(samplingRates, function(p) {multipleSamplingRun(sample, sample, numberOfSampling, samplingPercentage = p)})\n  \n  numberOfSampling <- samplingNumber[[6]]\n  sampling.6 <- sapply(samplingRates, function(p) {multipleSamplingRun(sample, sample, numberOfSampling, samplingPercentage = p)})\n  \n  f1.scores <- c(sampling.1[1,], sampling.2[1,], sampling.3[1,], sampling.4[1,], sampling.5[1,], sampling.6[1,])\n  precision <- c(sampling.1[2,], sampling.2[2,], sampling.3[2,], sampling.4[2,], sampling.5[2,], sampling.6[2,])\n  recall <- c(sampling.1[3,], sampling.2[3,], sampling.3[3,], sampling.4[3,], sampling.5[3,], sampling.6[3,])\n  samplingRatesAll <- rep(samplingRates, length(samplingNumber))\n  samplingNumberAll <- rep(samplingNumber, rep(length(samplingRates), length(samplingNumber)))\n  sampleNameAll <- rep(sampleName, length(samplingNumberAll))\n  \n  sample.performance <- data.frame(f1.scores, precision, recall, samplingRatesAll, samplingNumberAll, sampleNameAll)\n  return(sample.performance)\n}\n\nplotPerformancePDF <- function(sample.performance, sampleName) {\n  p <- ggplot(data = sample.performance, aes(y = f1.scores, x = samplingRatesAll, group = samplingNumberAll, color = samplingNumberAll))\n  p <- p + geom_line() + geom_point() + scale_color_gradientn(colours = rainbow(6))\n  pdf(paste0('./plots/', sampleName, '-f1score.pdf'), width = 15, height = 15)\n  print(p)\n  dev.off()\n  \n  p <- ggplot(data = sample.performance, aes(y = precision, x = samplingRatesAll, group = samplingNumberAll, color = samplingNumberAll))\n  p <- p + geom_line() + geom_point() + scale_color_gradientn(colours = rainbow(6))\n  pdf(paste0('./plots/', sampleName, '-precision.pdf'), width = 15, height = 15)\n  print(p)\n  dev.off()\n  \n  p <- ggplot(data = sample.performance, aes(y = recall, x = samplingRatesAll, group = samplingNumberAll, color = samplingNumberAll))\n  p <- p + geom_line() + geom_point() + scale_color_gradientn(colours = rainbow(6))\n  pdf(paste0('./plots/', sampleName, '-recall.pdf'), width = 15, height = 15)\n  print(p)\n  dev.off()\n}\n\nplotPerformance <- function(sample.performance, sampleName) {\n  p <- ggplot(data = sample.performance, aes(y = f1.scores, x = samplingRatesAll, group = samplingNumberAll, color = samplingNumberAll))\n  p <- p + geom_line() + geom_point() + scale_color_gradientn(colours = rainbow(6))\n  jpeg(paste0('./plots/', sampleName, '-f1score.jpeg'), width = 450, height = 450)\n  print(p)\n  dev.off()\n  \n  p <- ggplot(data = sample.performance, aes(y = precision, x = samplingRatesAll, group = samplingNumberAll, color = samplingNumberAll))\n  p <- p + geom_line() + geom_point() + scale_color_gradientn(colours = rainbow(6))\n  jpeg(paste0('./plots/', sampleName, '-precision.jpeg'), width = 450, height = 450)\n  print(p)\n  dev.off()\n  \n  p <- ggplot(data = sample.performance, aes(y = recall, x = samplingRatesAll, group = samplingNumberAll, color = samplingNumberAll))\n  p <- p + geom_line() + geom_point() + scale_color_gradientn(colours = rainbow(6))\n  jpeg(paste0('./plots/', sampleName, '-recall.jpeg'), width = 450, height = 450)\n  print(p)\n  dev.off()\n}\n\n# Load the data from the specified input folder\n# TODO: Since real data bam files will be added, update function so that it loads those bam files as well\nsyn1.data <- loadTrainingData(parentDirectory = '../data/training/', directory = 'syn1')\nsyn2.data <- loadTrainingData(parentDirectory = '../data/training/', directory = 'syn2')\nsyn3.data <- loadTrainingData(parentDirectory = '../data/training/', directory = 'syn3')\nsyn4.data <- loadTrainingData(parentDirectory = '../data/training/', directory = 'syn4')\nsyn5.data <- loadTrainingData(parentDirectory = '../data/training/', directory = 'syn5')\nreal1.data <- loadTrainingData(parentDirectory = '../data/training/', directory = 'real1')\n\n# Create the table structure that contains the SNP calls for the union of all candidate SNPs\nsyn1.predictions <- getAllPredictions(syn1.data)\nsyn2.predictions <- getAllPredictions(syn2.data)\nsyn3.predictions <- getAllPredictions(syn3.data)\nsyn4.predictions <- getAllPredictions(syn4.data)\nsyn5.predictions <- getAllPredictions(syn5.data)\nreal1.predictions <- getAllPredictions(real1.data)\n\n# Sample run with specified sampling number and rate for all samples\nnumberOfSampling <- 9\nsamplingPercentage <- 0.6\n\nmultipleSamplingRun(syn1.predictions, syn1.predictions, numberOfSampling, samplingPercentage)\nmultipleSamplingRun(syn2.predictions, syn2.predictions, numberOfSampling, samplingPercentage)\nmultipleSamplingRun(syn3.predictions, syn3.predictions, numberOfSampling, samplingPercentage)\nmultipleSamplingRun(syn4.predictions, syn4.predictions, numberOfSampling, samplingPercentage)\nmultipleSamplingRun(syn5.predictions, syn5.predictions, numberOfSampling, samplingPercentage)\nmultipleSamplingRun(real1.predictions, real1.predictions, numberOfSampling, samplingPercentage)\n\n# Calculate the f1 score, precision and recall for each classifier on each sample data\n\nevaluatePerformance(syn1.predictions$freebayesSNP, syn1.predictions$truthTable)\nevaluatePerformance(syn1.predictions$mutectSNP, syn1.predictions$truthTable)\nevaluatePerformance(syn1.predictions$vardictSNP, syn1.predictions$truthTable)\nevaluatePerformance(syn1.predictions$varscanSNP, syn1.predictions$truthTable)\n\nevaluatePerformance(syn2.predictions$freebayesSNP, syn2.predictions$truthTable)\nevaluatePerformance(syn2.predictions$mutectSNP, syn2.predictions$truthTable)\nevaluatePerformance(syn2.predictions$vardictSNP, syn2.predictions$truthTable)\nevaluatePerformance(syn2.predictions$varscanSNP, syn2.predictions$truthTable)\n\nevaluatePerformance(syn3.predictions$freebayesSNP, syn3.predictions$truthTable)\nevaluatePerformance(syn3.predictions$mutectSNP, syn3.predictions$truthTable)\nevaluatePerformance(syn3.predictions$vardictSNP, syn3.predictions$truthTable)\nevaluatePerformance(syn3.predictions$varscanSNP, syn3.predictions$truthTable)\n\nevaluatePerformance(syn4.predictions$freebayesSNP, syn4.predictions$truthTable)\nevaluatePerformance(syn4.predictions$mutectSNP, syn4.predictions$truthTable)\nevaluatePerformance(syn4.predictions$vardictSNP, syn4.predictions$truthTable)\nevaluatePerformance(syn4.predictions$varscanSNP, syn4.predictions$truthTable)\n\nevaluatePerformance(syn5.predictions$freebayesSNP, syn5.predictions$truthTable)\nevaluatePerformance(syn5.predictions$mutectSNP, syn5.predictions$truthTable)\nevaluatePerformance(syn5.predictions$vardictSNP, syn5.predictions$truthTable)\nevaluatePerformance(syn5.predictions$varscanSNP, syn5.predictions$truthTable)\n\nevaluatePerformance(real1.predictions$freebayesSNP, real1.predictions$truthTable)\nevaluatePerformance(real1.predictions$mutectSNP, real1.predictions$truthTable)\nevaluatePerformance(real1.predictions$vardictSNP, real1.predictions$truthTable)\nevaluatePerformance(real1.predictions$varscanSNP, real1.predictions$truthTable)\n\n#################################################################################\n# Calculate the f1 scores, precision and recall for different samling rates and sampling times\n# Store the calculated values in the performance folder in seralized manner\n#################################################################################\nsamplingRates <- seq(from = 0.05, to = 0.95, by = 0.05)\nsamplingNumber <- seq(from = 1, to = 11, by = 2)\n\ndir.create(file.path('./performance/'), showWarnings = FALSE)\nsampleName <- 'syn1'\nsyn1.performance <- getPerformance(syn1.predictions, sampleName, samplingRates, samplingNumber)\nsaveRDS(syn1.performance, file = './performance/syn1Performace.rds')\nsampleName <- 'syn2'\nsyn2.performance <- getPerformance(syn2.predictions, sampleName, samplingRates, samplingNumber)\nsaveRDS(syn2.performance, file = './performance/syn2Performace.rds')\nsampleName <- 'syn3'\nsyn3.performance <- getPerformance(syn3.predictions, sampleName, samplingRates, samplingNumber)\nsaveRDS(syn3.performance, file = './performance/syn3Performace.rds')\nsampleName <- 'syn4'\nsyn4.performance <- getPerformance(syn4.predictions, sampleName, samplingRates, samplingNumber)\nsaveRDS(syn4.performance, file = './performance/syn4Performace.rds')\nsampleName <- 'syn5'\nsyn5.performance <- getPerformance(syn5.predictions, sampleName, samplingRates, samplingNumber)\nsaveRDS(syn5.performance, file = './performance/syn5Performace.rds')\nsampleName <- 'real1'\nreal1.performance <- getPerformance(real1.predictions, sampleName, samplingRates, samplingNumber)\nsaveRDS(real1.performance, file = './performance/real1Performace.rds')\n\n\n###########################\n# The first part is to generate the predictions and caldulate the f1 scores, precision & recall\n# Code below just loads the already calculated and stored scores and plots the graphs\n###########################\n\nsyn1.performance <- readRDS('./performance/syn1Performace.rds')\nsyn2.performance <- readRDS('./performance/syn2Performace.rds')\nsyn3.performance <- readRDS('./performance/syn3Performace.rds')\nsyn4.performance <- readRDS('./performance/syn4Performace.rds')\nsyn5.performance <- readRDS('./performance/syn5Performace.rds')\nreal1.performance <- readRDS('./performance/real1Performace.rds')\n\ndir.create(file.path('./plots'), showWarnings = FALSE)\nplotPerformance(syn1.performance, 'syn1')\nplotPerformance(syn2.performance, 'syn2')\nplotPerformance(syn3.performance, 'syn3')\nplotPerformance(syn4.performance, 'syn4')\nplotPerformance(syn5.performance, 'syn5')\nplotPerformance(real1.performance, 'real1')\n\n\n\n\n\n\n",
    "created" : 1459494293724.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "285385985",
    "id" : "AB1DC8EE",
    "lastKnownWriteTime" : 1459749761,
    "last_content_update" : 1459749761529,
    "path" : "C:/Users/ddemircioglu/Desktop/Lectures/2015-2016 Spring/CS6222 - Advanced Topics in Computational Biology/Project/CS6222/main.R",
    "project_path" : "main.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}